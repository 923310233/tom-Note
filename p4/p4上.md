# P4

## 从OpenFlow说起

OpenFlow在SDN中扮演的角色:

![1.png](./image/1.png)

SDN的一个重要概念就是控制平面和数据平面的分离，以及集中式的控制平面，这个集中的控制平面就是我们所说的**控制器**。

那么控制平面与数据平面分离之后，如何像往常一样管理数据平面呢？因此，**在分离后的控制平面和数据平面之间，只能通过一个特定的协议进行交互**，这个协议就是我们的OpenFlow协议。

OpenFlow必须是一个 target-independent 的协议，所谓target-independent就是与 特定的交换机无关，能够提供一种抽象，从而可以以统一的接口管理网络中所有的设备，从而实现一个逻辑集中的控制平面。

OpenFlow作为一种南向协议，其与其他南向接口的对比如下:

![2.png](./image/2.png)

OpenFlow虽然实现了Target-independent，但是没有实现Protocol-independent。 这个是OpenFlow的最主要的缺陷之一，这也是引入P4的最主要的原因。



什么是Protocol-independent呢:

**OpenFlow的缺陷**:OpenFlow虽然为SDN奠定了基础。但是在进行应用开发的时候有一个很大的局限，就是OpenFlow没有真正做到协议不相关。也就是说，**OpenFlow只能依据现有的协议来定义流表项**。打个比方，就好像OpenFlow给了我们几个固定形状的积木，让我们自行组装，却不能让我们自己定义积木的形状。 这就是OpenFlow的局限所在.

举个例子：OpenFlow 1.0 的时候有12个字段，这些字段分别就是我们熟悉的，IP地址，MAC地址，等等。但是很快发现，单单这12个字段不能满足现实网络世界中各种需求（在网络中的协议有很多种）。所以到OpenFlow1.3的时候字段增加到40个，现在OpenFlow1.5甚至更多。

这样带来的麻烦有很多，一是匹配效率和空间占用的问题。二是特定的OpenFlow交换机生产出来后，无法支持新的协议字段，只能在现有协议上进行开发。最终只能面临淘汰。

**如果我们可以自定义协议字段的类型，甚至实现自定义动作的类型，那么我们就不需要反复修正协议本身，SDN的架构也将更加灵活**。这个**自定义协议字段类型**，**自定义动作类型**就是我们所说的数据面编程。

数据面编程就是我们自己定义匹配字段，自己定义动作类型，从而自己定义流表，进而形成流水线（pipline）。基于这种初衷，P4应运而生。



## P4

P4(**P**rogramming **P**rotocol-Independent **P**acket **P**rocessors)是一种数据面的高级编程语言。他可以克服OpenFlow的局限。通过P4语言，我们可以定义我们想要的数据面。进而再通过南向协议添加流表项。



P4 与 OpenFlow 的关联与区别:

**P4虽然弥补了OpenFlow的不足，但是P4和OpenFlow的定位是截然不同的！** OpenFlow提供了一种控制器和数据面的**动态交互**的协议。是一种南向协议。

而P4只是一个数据面的编程语言。



通过P4，我们可以定义各种各样形状的积木，而通过南向协议，我们可以组装这些积木来实现特定的功能。也就是说，**写好P4代码并不是全部，我们还需要写相应的控制面代码才能使网络正常工作**。

与OpenFlow对应的是**P4 Runtime**。 还记的上面的那张图吗，为了实现协议无关。P4的设计者们还提供了一个南向协议——P4 runtime。 **P4 runtime与OpenFlow功能类似**，但是P4 runtime可以充分利用P4协议无关的特性，”与P4更搭配。

### V1Model

![3.png](./image/3.png)

这是P4中提供的最简单最易理解的编程结构，V1Model。可以看到它由5个模块组成，他们的名字分别是(从左到右)：

- Parser: 解析器， 解析并且提取数据包头的各个字段。
- Ingress： Ingress处理，在这里定义Ingress流水线。
- TM： Traffic manager，有一些队列，用于流量控制（一些队列相关的metadata在此更新）。
- Egress： Egress, 在这里定义Egress流水线。
- Deparser：用于重组数据包，因为数据包在处理过程中经历了分解和处理。所以最后转发的时候需要重组一下。

P4为我们提供了上述抽象，我们就可以把所有的交换机理解为上述的模型，然后按照上述模型进行开发就可以了。所以，按照上述模型，P4语言的代码结构通常为这样:



































数据平面：维护一个由一系列流表组成的(pipeline，流水线)。当数据包经过交换机时，首先会走的是数据平面，即去匹配这些表。根据匹配到的相应的规则（action），如output, drop。从不同的端口转发或者丢弃。

控制平面：不管是分布式的控制平面，还是集中式的控制平面。控制平面可以理解为网元设备的操作系统。他可以写一些程序，里面含有特定的算法，向数据平面添加相应的转发规则。也就是说，控制平面相当于网元设备的大脑，当数据平面不知道如何转发一个数据包时，会向大脑询问，大脑根据自己对网络拓扑的”认知“，向数据平面返回指定的规则，数据平面记录这条规则，在之后的转发过程中，就不再询问自己的大脑（速率较慢），而是根据“肌肉记忆”直接转发。